/* Generated by re2c 2.0.3 */
#include "parser.h"

#define YYCURSOR s.begin
#define YYLIMIT s.limit
#define YYCTYPE unsigned char
#define YYMARKER s.marker
#define YYGETCONDITION() s.state
#define YYSETCONDITION(cond) s.state=(yyc##cond)
#define GOTO(cond) goto yyc_##cond
#define SETANDJUMPTO(cond) YYSETCONDITION(cond); GOTO(cond)


std::shared_ptr<kind> make_INT(int i, location loc) {
    return std::make_shared<symbol<int>>(INT, i, loc);
}

std::shared_ptr<kind> make_LONG(long i, location loc) {
    return std::make_shared<symbol<long>>(LONG, i, loc);
}

std::shared_ptr<kind> make_YYEOF(location loc) {
    return std::make_shared<symbol<bool>>(YYEOF, false, loc);
}

std::shared_ptr<kind> make_YYERROR(location loc) {
    return std::make_shared<symbol<bool>>(YYERROR, false, loc);
}

std::shared_ptr<kind> make_DOBLE(double d, location loc) {
    return std::make_shared<symbol<double>>(DOUBLE, d, loc);
}

std::shared_ptr<kind> make_BOOL(bool b, location loc) {
    return std::make_shared<symbol<bool>>(BOOL, b, loc);
}

std::shared_ptr<kind> make_HEX(long i, const std::string &v, location loc) {
    return std::make_shared<symbol<json::hex>>(HEX, json::hex(i, v), loc);
}

std::shared_ptr<kind> make_STRING(const std::string &str, location loc) {
    return std::make_shared<symbol<std::string>>(STRING, str, loc);
}

std::shared_ptr<kind> make_NULL(location loc) {
    return std::make_shared<symbol<bool>>(NUL, false, loc);
}

std::shared_ptr<kind> make_SYMBOL(int t, location loc) {
    return std::make_shared<symbol<bool>>(t, false, loc);
}

/* add logic for real implementation */
std::shared_ptr<kind> make_ARRAY(location loc) {
    return std::make_shared<symbol<bool>>(ARRAY, false, loc);
}

std::shared_ptr<kind> make_OBJECT(location loc) {
    return std::make_shared<symbol<bool>>(OBJECT, false, loc);
}

std::shared_ptr<kind> make_NAN(json::nan n,location loc) {
    return std::make_shared<symbol<json::nan>>(NaN, n, loc);
}

std::shared_ptr<kind> make_INF(json::infinity i,location loc) {
    return std::make_shared<symbol<json::infinity>>(INF, i, loc);
}


std::string json::get_string() {
    if (this->is<const char *>()) {
        return std::string(this->get<const char *>());
    } else {
        return this->get<std::string>();
    }
}



std::string json::toPrettyString(bool hex) {
    this->pretty = true;
    return this->toString(hex);
}

std::string json::toString(bool hex)
{
    if (this->is_array()) {
        if (this->pretty) this->identity.append("\t");
        std::string str = "[";
        auto v = this->get_array();
        if (this->pretty && !this->identity.empty()) {
            str.append("\n");
        }
        for (auto i = 0; i < v.size(); i++) {
            if (this->pretty && !this->identity.empty()) {
                str.append(this->identity);
                auto e = v.at(i);
                e.pretty = this->pretty;
                e.identity = this->identity;
                str = str.append(e.toString(hex));
            } else {
                str = str.append( v.at(i).toString(hex));
            }
            if (i < v.size() - 1) {
                str = str.append(",");
                if ( this->pretty && !this->identity.empty()) {
                    str.append("\n");
                }
            }
        }
        if (this->pretty && !this->identity.empty()) {
            this->identity = this->identity.substr(0, this->identity.size()-1);
            str.append("\n").append(this->identity);
        }
        return str.append("]");
    }

    if (this->is_object()) {
        if (this->pretty) this->identity.append("\t");
        auto i = 0;
        auto m = this->get_object();
        std::string str = "{";
        if (this->pretty && !this->identity.empty()) {
            str.append("\n");
        }
        for (auto begin = m.begin(); begin != m.end(); begin++, i++) {
            if (this->pretty && !this->identity.empty()) {
                str.append(this->identity).append("\"").append(begin->first).append("\":");
                begin->second.pretty = this->pretty;
                begin->second.identity = this->identity;
                str = str.append(begin->second.toString(hex));
            } else {
                str = str.append("\"").append(begin->first).append("\":");
                str = str.append(begin->second.toString(hex));
            }
            if (i < m.size() -1) {
                str = str.append(",");
                if (this->pretty && !this->identity.empty()) {
                    str.append("\n");
                }
            }
        }
        if (this->pretty && !this->identity.empty()) {
            this->identity = this->identity.substr(0, this->identity.size()-1);
            str.append("\n").append(this->identity);
        }

        return str.append("}");
    }

    if (this->is_double()) {
        return std::to_string(this->get_double());
    }
    if (this->is_float()) {
        return std::to_string(this->get_float());
    }
    if (this->is_int()) {
        return std::to_string(this->get_int());
    }
    if (this->is_long()) {
        return std::to_string(this->get_long());
    }

    if (this->is_string()) {
        std::string p{};
        for (auto c : this->get_string()) {
            if (c == '"') {
                p = p.append(1, '\\');
            }
            p = p.append(1, c);
        }
        return std::string("\"").append(p).append("\"");
    }
    if (this->is_null()) {
        return "null";
    }

    if (this->is_infinity()) {
        if (this->get_infinity().neg) {
            return "-Infinity";
        } else {
            return "Infinity";
        }
    }

    if (this->is_nan()) {
        return "NaN";
    }

    if (this->is_hex()) {
        if (hex) {
            return this->get_hex().raw_value;
        } else {
            return std::to_string(this->get_hex().value);
        }
    }

    if (this->is_bool()) {
        if (this->get_bool().yes) {
            return "true";
        } else {
            return "false";
        }
    }

    return "";
}

template<>
json::json(std::initializer_list<json> t): ptr( new data<array>(t) ) { name = typeid(array).name(); }

template<>
json::json(bool t): ptr( new data<boolean>(t) ) { name = typeid(boolean).name(); }


json parser::parse(const std::string &buffer) {
    s.start = s.begin = (char *)buffer.data();
    s.limit = s.begin + buffer.size();
    s.loc = location();
    s.state = 0;
    return this->parse_value();
}


json parser::get_token_value(std::shared_ptr<kind> token) {
    switch (token->token) {
        case LONG:
            return get_value<long>(token);
        case DOUBLE:
            return get_value<double>(token);
        case BOOL:
            return get_value<bool>(token);
        case STRING:
            return get_value<std::string>(token);
        case NUL:
            return json::null();
        case NaN:
            return get_value<json::nan>(token);
        case HEX:
            return get_value<json::hex>(token);
        case INF:
            return get_value<json::infinity>(token);
        case '{':
            return this->parse_object();
        case '[':
            return this->parse_array();
        default:
            throw exitWithError("Unknown token");
    }
}

json parser::parse_value() {
    auto token = yylex(s);
    return this->get_token_value(token);
}


json::object parser::parse_object() {
    json::object obj;
more_kvs:
    auto field = yylex(s);
    if (field->token == '}') {
        return obj;
    }
    if (field->token != STRING) {
        throw exitWithError("Unknown token");
    }
    auto colon = yylex(s);
    if (colon->token != ':') {
        throw exitWithError("object field need a colon symbol before value");
    }
    auto value = this->parse_value();
    obj.insert({get_value<std::string>(field), value });

    auto has_more = yylex(s);
    if (has_more->token == ',') {
        goto more_kvs;
    } else if (has_more->token == '}'){
        return obj;
    } else {
        throw exitWithError("object must be end with }.");
    }
}

json::array parser::parse_array() {
    json::array array;
more_elements:
    auto ele = yylex(s);
    if (ele->token == ']') {
        return array;
    }
    json e = this->get_token_value(ele);
    array.push_back(e);
    auto deli = yylex(s);
    if (deli->token == ']') {
        return array;
    } else if (deli->token == ',') {
        goto more_elements;
    } else {
        throw exitWithError("array must be end with ].");
    }
}

std::shared_ptr<kind> yylex(scanner &s) {

std:
    std::string data{};
    char *begin = s.begin;

	{
		YYCTYPE yych;
		unsigned int yyaccept = 0;
		if (YYGETCONDITION() < 2) {
			if (YYGETCONDITION() < 1) {
				goto yyc_JSON;
			} else {
				goto yyc_STR;
			}
		} else {
			if (YYGETCONDITION() < 3) {
				goto yyc_STR1;
			} else {
				if (YYGETCONDITION() < 4) {
					goto yyc_COMMENTS;
				} else {
					goto yyc_COMMENTS1;
				}
			}
		}
/* *********************************** */
yyc_JSON:
		{
			static const unsigned char yybm[] = {
				  0,   0,   0,   0,   0,   0,   0,   0, 
				  0,  16,   0,   0,   0,  16,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				 16,   0,   0,   0,   0,   0,   0,   0, 
				  0,   0,   0,   0,   0,   0,   0,   0, 
				224, 224, 224, 224, 224, 224, 224, 224, 
				224, 224,   0,   0,   0,   0,   0,   0, 
				  0, 192, 192, 192, 192, 192, 192,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,   0,   0,   0,   0,  64, 
				  0, 192, 192, 192, 192, 192, 192,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,   0,   0,   0,   0,   0, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
				 64,  64,  64,  64,  64,  64,  64,  64, 
			};
			yych = *YYCURSOR;
			if (yych <= ':') {
				if (yych <= '#') {
					if (yych <= '\f') {
						if (yych <= 0x08) {
							if (yych <= 0x00) goto yy3;
						} else {
							if (yych <= '\t') goto yy5;
							if (yych <= '\n') goto yy8;
						}
					} else {
						if (yych <= ' ') {
							if (yych <= '\r') goto yy10;
							if (yych >= ' ') goto yy5;
						} else {
							if (yych <= '!') goto yy2;
							if (yych <= '"') goto yy11;
							goto yy13;
						}
					}
				} else {
					if (yych <= ',') {
						if (yych <= '\'') {
							if (yych >= '\'') goto yy15;
						} else {
							if (yych <= '*') goto yy2;
							if (yych <= '+') goto yy17;
							goto yy18;
						}
					} else {
						if (yych <= '/') {
							if (yych <= '-') goto yy20;
							if (yych <= '.') goto yy21;
							goto yy24;
						} else {
							if (yych <= '0') goto yy25;
							if (yych <= '9') goto yy27;
							goto yy29;
						}
					}
				}
			} else {
				if (yych <= '_') {
					if (yych <= 'N') {
						if (yych <= 'H') {
							if (yych >= 'A') goto yy31;
						} else {
							if (yych <= 'I') goto yy34;
							if (yych <= 'M') goto yy31;
							goto yy35;
						}
					} else {
						if (yych <= '\\') {
							if (yych <= 'Z') goto yy31;
							if (yych <= '[') goto yy36;
						} else {
							if (yych <= ']') goto yy38;
							if (yych >= '_') goto yy31;
						}
					}
				} else {
					if (yych <= 'n') {
						if (yych <= 'h') {
							if (yych >= 'a') goto yy31;
						} else {
							if (yych <= 'i') goto yy34;
							if (yych <= 'm') goto yy31;
							goto yy35;
						}
					} else {
						if (yych <= '|') {
							if (yych <= 'z') goto yy31;
							if (yych <= '{') goto yy40;
						} else {
							if (yych <= '}') goto yy42;
							if (yych >= 0x80) goto yy31;
						}
					}
				}
			}
yy2:
			YYCURSOR = YYMARKER;
			if (yyaccept == 0) {
				goto yy23;
			} else {
				goto yy26;
			}
yy3:
			++YYCURSOR;
			{ return make_YYEOF(s.loc); }
yy5:
			yych = *++YYCURSOR;
yy6:
			if (yybm[0+yych] & 16) {
				goto yy5;
			}
			{
    s.loc.columns(s.begin - begin);
    goto std;
}
yy8:
			++YYCURSOR;
			{
    s.loc.lines(1);
    goto std;
}
yy10:
			yych = *++YYCURSOR;
			if (yych == '\n') goto yy8;
			goto yy6;
yy11:
			++YYCURSOR;
			{
    s.loc.columns(s.begin - begin);
    begin = s.begin;
    SETANDJUMPTO(STR);
}
yy13:
			++YYCURSOR;
			{
    s.loc.columns(s.begin - begin);
    SETANDJUMPTO(COMMENTS);
}
yy15:
			++YYCURSOR;
			{
    s.loc.columns(1);
    begin = s.begin;
    SETANDJUMPTO(STR1);
}
yy17:
			yych = *++YYCURSOR;
			if (yych <= 'H') {
				if (yych <= '/') goto yy2;
				if (yych <= '0') goto yy44;
				if (yych <= '9') goto yy27;
				goto yy2;
			} else {
				if (yych <= 'I') goto yy45;
				if (yych == 'i') goto yy45;
				goto yy2;
			}
yy18:
			++YYCURSOR;
			{ s.loc.columns(s.begin - begin); return make_SYMBOL(',', s.loc); }
yy20:
			yych = *++YYCURSOR;
			if (yych <= 'H') {
				if (yych <= '/') goto yy2;
				if (yych <= '0') goto yy44;
				if (yych <= '9') goto yy27;
				goto yy2;
			} else {
				if (yych <= 'I') goto yy46;
				if (yych == 'i') goto yy46;
				goto yy2;
			}
yy21:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yybm[0+yych] & 32) {
				goto yy21;
			}
			if (yych == 'E') goto yy47;
			if (yych == 'e') goto yy47;
yy23:
			{
    s.loc.columns(s.begin - begin);
    std::string t(begin, s.begin);
    double d = std::strtod(t.data(), nullptr);
    return make_DOBLE(d, s.loc);
}
yy24:
			yych = *++YYCURSOR;
			if (yych == '*') goto yy48;
			if (yych == '/') goto yy13;
			goto yy2;
yy25:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 'W') {
				if (yych <= '.') {
					if (yych >= '.') goto yy21;
				} else {
					if (yych == 'E') goto yy47;
				}
			} else {
				if (yych <= 'e') {
					if (yych <= 'X') goto yy50;
					if (yych >= 'e') goto yy47;
				} else {
					if (yych == 'x') goto yy50;
				}
			}
yy26:
			{
    s.loc.columns(s.begin - begin);
    std::string t(begin, s.begin);
    long l = std::strtol(t.data(), nullptr, 10);
    return make_LONG(l, s.loc);
}
yy27:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= '9') {
				if (yych == '.') goto yy21;
				if (yych <= '/') goto yy26;
				goto yy27;
			} else {
				if (yych <= 'E') {
					if (yych <= 'D') goto yy26;
					goto yy47;
				} else {
					if (yych == 'e') goto yy47;
					goto yy26;
				}
			}
yy29:
			++YYCURSOR;
			{ s.loc.columns(s.begin - begin); return make_SYMBOL(':', s.loc); }
yy31:
			yych = *++YYCURSOR;
yy32:
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{
    std::string v(begin, s.begin);
    return make_STRING(v, s.loc);
}
yy34:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy51;
			if (yych == 'n') goto yy51;
			goto yy32;
yy35:
			yych = *++YYCURSOR;
			if (yych == 'A') goto yy52;
			if (yych == 'a') goto yy52;
			goto yy32;
yy36:
			++YYCURSOR;
			{ s.loc.columns(s.begin - begin); return make_SYMBOL('[', s.loc); }
yy38:
			++YYCURSOR;
			{ s.loc.columns(s.begin - begin); return make_SYMBOL(']', s.loc); }
yy40:
			++YYCURSOR;
			{ s.loc.columns(s.begin - begin); return make_SYMBOL('{', s.loc); }
yy42:
			++YYCURSOR;
			{ s.loc.columns(s.begin - begin); return make_SYMBOL('}', s.loc); }
yy44:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 'D') {
				if (yych == '.') goto yy21;
				goto yy26;
			} else {
				if (yych <= 'E') goto yy47;
				if (yych == 'e') goto yy47;
				goto yy26;
			}
yy45:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy53;
			if (yych == 'n') goto yy53;
			goto yy2;
yy46:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy54;
			if (yych == 'n') goto yy54;
			goto yy2;
yy47:
			yych = *++YYCURSOR;
			if (yych <= ',') {
				if (yych == '+') goto yy55;
				goto yy2;
			} else {
				if (yych <= '-') goto yy55;
				if (yych <= '/') goto yy2;
				if (yych <= '9') goto yy56;
				goto yy2;
			}
yy48:
			++YYCURSOR;
			{
    s.loc.columns(s.begin - begin);
    SETANDJUMPTO(COMMENTS1);
}
yy50:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 128) {
				goto yy58;
			}
			goto yy2;
yy51:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy61;
			if (yych == 'f') goto yy61;
			goto yy32;
yy52:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy62;
			if (yych == 'n') goto yy62;
			goto yy32;
yy53:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy64;
			if (yych == 'f') goto yy64;
			goto yy2;
yy54:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy65;
			if (yych == 'f') goto yy65;
			goto yy2;
yy55:
			yych = *++YYCURSOR;
			if (yych <= '/') goto yy2;
			if (yych >= ':') goto yy2;
yy56:
			yych = *++YYCURSOR;
			if (yych <= '/') goto yy23;
			if (yych <= '9') goto yy56;
			goto yy23;
yy58:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 128) {
				goto yy58;
			}
			{
    s.loc.columns(s.begin - begin);
    std::string t(begin, s.begin);
    long i = std::strtol(t.data(), nullptr, 16);
    return make_HEX(i, t, s.loc);
}
yy61:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy66;
			if (yych == 'i') goto yy66;
			goto yy32;
yy62:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
			{ s.loc.columns(s.begin - begin); return make_NAN(json::nan(), s.loc); }
yy64:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy67;
			if (yych == 'i') goto yy67;
			goto yy2;
yy65:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy68;
			if (yych == 'i') goto yy68;
			goto yy2;
yy66:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy69;
			if (yych == 'n') goto yy69;
			goto yy32;
yy67:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy70;
			if (yych == 'n') goto yy70;
			goto yy2;
yy68:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy71;
			if (yych == 'n') goto yy71;
			goto yy2;
yy69:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy72;
			if (yych == 'i') goto yy72;
			goto yy32;
yy70:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy73;
			if (yych == 'i') goto yy73;
			goto yy2;
yy71:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy74;
			if (yych == 'i') goto yy74;
			goto yy2;
yy72:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy75;
			if (yych == 't') goto yy75;
			goto yy32;
yy73:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy76;
			if (yych == 't') goto yy76;
			goto yy2;
yy74:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy77;
			if (yych == 't') goto yy77;
			goto yy2;
yy75:
			yych = *++YYCURSOR;
			if (yych == 'Y') goto yy78;
			if (yych == 'y') goto yy78;
			goto yy32;
yy76:
			yych = *++YYCURSOR;
			if (yych == 'Y') goto yy80;
			if (yych == 'y') goto yy80;
			goto yy2;
yy77:
			yych = *++YYCURSOR;
			if (yych == 'Y') goto yy81;
			if (yych == 'y') goto yy81;
			goto yy2;
yy78:
			yych = *++YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy31;
			}
yy79:
			{ s.loc.columns(s.begin - begin); return make_INF(json::infinity(), s.loc);      }
yy80:
			++YYCURSOR;
			goto yy79;
yy81:
			++YYCURSOR;
			{ s.loc.columns(s.begin - begin); return make_INF(json::infinity(true), s.loc);  }
		}
/* *********************************** */
yyc_STR:
		yych = *YYCURSOR;
		if (yych <= '\n') {
			if (yych <= 0x00) goto yy85;
			if (yych <= '\t') goto yy87;
			goto yy89;
		} else {
			if (yych == '"') goto yy91;
			goto yy87;
		}
yy85:
		++YYCURSOR;
		{
    s.msg = "double-quotation-marks string unclosed";
    goto syntax_error;
}
yy87:
		++YYCURSOR;
		{
    s.loc.columns(1);
    SETANDJUMPTO(STR);
}
yy89:
		++YYCURSOR;
		{
    if (*(s.begin - 2) == '\r') {
        if (*(s.begin - 3) != '\\') {
            s.msg = "new-line string must escaped by slash \\";
            goto syntax_error;
        }
        data.append(begin, s.begin-3);
    } else {
        if (*(s.begin-2) != '\\') {
            s.msg = "new-line string must escaped by slash \\";
            goto syntax_error;
        }
        data.append(begin, s.begin-2);
    }
    begin = s.begin;
    s.loc.lines(1);
    SETANDJUMPTO(STR);
}
yy91:
		++YYCURSOR;
		{
    std::string v(begin, s.begin-1);
    if (data.size() >= 1) {
        v = data + v;
    }
    data.clear();
    YYSETCONDITION(JSON);
    return make_STRING(v, s.loc);
}
/* *********************************** */
yyc_STR1:
		yych = *YYCURSOR;
		if (yych <= '\n') {
			if (yych <= 0x00) goto yy95;
			if (yych <= '\t') goto yy97;
			goto yy99;
		} else {
			if (yych == '\'') goto yy101;
			goto yy97;
		}
yy95:
		++YYCURSOR;
		{
    s.msg = "double-quotation-marks string unclosed";
    goto syntax_error;
}
yy97:
		++YYCURSOR;
		{
    s.loc.columns(s.begin-begin);
    SETANDJUMPTO(STR1);
}
yy99:
		++YYCURSOR;
		{
    if (*(s.begin - 2) == '\r') {
        if (*(s.begin - 3) != '\\') {
            goto syntax_error;
        }
        data.append(begin, s.begin-3);
    } else {
        if (*(s.begin-2) != '\\') {
            goto syntax_error;
        }
        data.append(begin, s.begin-2);
    }
    begin = s.begin;
    s.loc.lines(1);
    SETANDJUMPTO(STR1);
}
yy101:
		++YYCURSOR;
		{
    std::string v(begin, s.begin-1);
    if (data.size() >= 1) {
        v = data + v;
    }
    data.clear();
    YYSETCONDITION(JSON);
    return make_STRING(v, s.loc);
}
/* *********************************** */
yyc_COMMENTS:
		yych = *YYCURSOR;
		if (yych == '\n') goto yy107;
		++YYCURSOR;
		{
    s.loc.columns(1);
    SETANDJUMPTO(COMMENTS);
}
yy107:
		++YYCURSOR;
		{
     s.loc.lines(1);
     begin = s.begin;
     SETANDJUMPTO(JSON);
}
/* *********************************** */
yyc_COMMENTS1:
		yych = *YYCURSOR;
		if (yych == '\n') goto yy112;
		if (yych == '*') goto yy114;
yy111:
yy112:
		++YYCURSOR;
		{
    s.loc.lines(1);
    SETANDJUMPTO(COMMENTS1);
}
yy114:
		yych = *++YYCURSOR;
		if (yych != '/') goto yy111;
		++YYCURSOR;
		{
    s.loc.columns(s.begin - begin);
    begin = s.begin;
    SETANDJUMPTO(JSON);
}
	}

syntax_error:
    return make_YYERROR(s.loc);
}